# 회원가입 유효성 검사와 중복검사(Validation)

### 설정(build.gradle)

```
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

> Validation 어노테이션을 사용하기 위해 
spring boot 2.3 버전 부터는 validation 의존성을 따로 추가 해줘야 한다.
> 

### 구현 화면

![Untitled](%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AA%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1(Validation)%2026954e291c5f4a688c750785f8fed9d6/Untitled.png)

![Untitled](%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AA%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1(Validation)%2026954e291c5f4a688c750785f8fed9d6/Untitled%201.png)

### **접근 로직**

1. **단순 유효성 검사**와 관련해서는 Validation 어노테이션으로 접근
⇒ 내용을 입력하지 않거나/형식에 맞지 않으면 ⇒ 어노테이션의 설정 Message 출력.
2. **중복 검사**에 관해서는 가입버튼을 누르면 이동하는 URL 을 매핑하는 컨트롤러에서
⇒ 아이디/닉네임/이메일 중복과 관련된 Validator 를 빈으로 등록한뒤 
⇒ Validator 결과를 컨트롤러의 model 에 담아 다시 가입창에 정보 전달
    
    > 중복 검사 로직에 대해서 좀더 자세히 접근 하면
    `AbstractValidator` 추상 클래스에서 유효성 메서드 형식 제공
     ⇒`CustomValidators` 에서 `AbstractValidator` 클래스를 상속 받아 
    아이디/닉네임/이메일 중복과 관련하여 메서드 오버라이드 
    + 이때 오버라이드 메서드 에서  `UserRepository` 를 통해 Spring Data Jpa 사용
     ⇒ 최종적으로 `UserController` 에서 `CustomValidators` 의 각 Validator 들을 빈으로 등록 
    ⇒ 등록된 Validator 들을 이용하여 나온 error 정보를 
    `UserService` 의 유효성 및 중복 검사에 해당하는`validateHandling` 사용하여 model로 전달
    > 

---

[PostsDto.java ](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20DTO%20e4796b1ecaac44c5b495db7268744b97.md) 

> 유효성 검사가 필요한 Request 객체에 Validation 어노테이션 사용
> 

---

### user/user-join.html

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<!--<head th:replace="~{layout/header :: head}">
    <title>회원가입</title>
</head>-->
<body>
<div th:replace="~{layout/header :: header}"></div>

<div id="posts_list">
    <div class="container col-md-4">
        <form th:action="@{/auth/joinProc}" method="post">
            <input type="hidden" name="_csrf" th:value="${_csrf.token}"/>
            <div class="form-group">
                <label>아이디</label>
                <input type="text" name="username" th:value="${userDto?.username}" class="form-control" placeholder="아이디를 입력해주세요"/>
                <span th:if="${valid_username}" th:text="${valid_username}" id="valid"></span>
            </div>

            <div class="form-group">
                <label>비밀번호</label>
                <input type="password" name="password" th:value="${userDto?.password}" class="form-control" placeholder="비밀번호를 입력해주세요"/>
                <span th:if="${valid_password}" th:text="${valid_password}" id="valid"></span>
            </div>

            <div class="form-group">
                <label>닉네임</label>
                <input type="text" name="nickname" th:value="${userDto?.nickname}" class="form-control" placeholder="닉네임을 입력해주세요"/>
                <span th:if="${valid_nickname}" th:text="${valid_nickname}" id="valid"></span>
            </div>

            <div class="form-group">
                <label>이메일</label>
                <input type="email" name="email" th:value="${userDto?.email}" class="form-control" placeholder="이메일을 입력해주세요"/>
                <span th:if="${valid_email}" th:text="${valid_email}" id="valid"></span>
            </div>

            <button type="submit" class="btn btn-primary bi bi-person"> 가입</button>
            <a href="/" role="button" class="btn btn-info bi bi-arrow-return-left"> 목록</a>
        </form>
    </div>
</div>

<div th:replace="~{layout/footer :: footer}"></div>
</body>
</html>

```

---

### UserRepository.java

Spring Data JPA 를 이용하는 인터페이스.

```java
public interface UserRepository extends JpaRepository<User, Long> {
    /* Security */
    Optional<User> findByUsername(String username);

    /* OAuth */
    Optional<User> findByEmail(String email);

    /* user GET */
    User findByNickname(String nickname);

    /* 중복 검사> 중복인 경우 true, 중복되지 않은경우 false 리턴 */

    boolean existsByUsername(String username);

    boolean existsByNickname(String nickname);

    boolean existsByEmail(String email);

}
```

Spring Data JPA 에서는 `exists` 를 통해 데이터가 존재하는지 확인
⇒ 존재하면 True , 존재하지 않으면 False 리턴

### AbstractValidator.java

`validate` 를 구현하고 검증로직의 부분은 `doValidate` 로 따로 분리.

```java
@Slf4j
public abstract class AbstractValidator<T> implements Validator {
    @Override
    public boolean supports(Class<?> clazz) {
        return true;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void validate(Object target, Errors errors) {
        try {
            doValidate((T) target, errors);
        } catch (IllegalStateException e) {
            log.error("중복 검증 에러",e);
            throw e;
        }
    }

    protected abstract void doValidate(final T dto,final Errors errors);
}
```

- `@SuppressWarnings( “unchecked” )` 
: 컴파일러에서 경고하지 않게 어노테이션 설정
    
    

### CustomValidators.java

**UserRepository** 를 선언하고 **AbstractValidator** 메서드 오버라이드

```java
@RequiredArgsConstructor
@Component
public class CustomValidators {
    @RequiredArgsConstructor
    @Component
    public static class EmailValidator extends AbstractValidator<UserDto.Request> {
        private final UserRepository userRepository;

        @Override
        protected void doValidate(UserDto.Request dto, Errors errors) {
            if (userRepository.existsByEmail(dto.toEntity().getEmail())) {
                errors.rejectValue("email","이메일 중복 오류","이미 사용중인 아이디 입니다.");
            }
        }
    }
    @RequiredArgsConstructor
    @Component
    public static class NicknameValidator extends AbstractValidator<UserDto.Request> {
        private final UserRepository userRepository;

        @Override
        protected void doValidate(UserDto.Request dto, Errors errors) {
            if (userRepository.existsByNickname(dto.toEntity().getNickname())) {
                errors.rejectValue("nickname","닉네임 중복 오류" ,"이미 사용중인 닉네임 입니다.");
            }
        }
    }
    @RequiredArgsConstructor
    @Component
    public static class UsernameValidator extends AbstractValidator<UserDto.Request> {
        private final UserRepository userRepository;

        @Override
        protected void doValidate(UserDto.Request dto, Errors errors) {
            if (userRepository.existsByUsername(dto.toEntity().getUsername())) {
                errors.rejectValue("username","아이디 중복 오류", "이미 사용중인 아이디 입니다.");
            }
        }
    }

}
```

> AbstractValidator 의 doValidate 를 오버라이드 하여 검증로직을 작성하고 
`@Component` 어노테이션으로 빈 등록.
> 

### UserService.java

Error 정보를 통해 중복 검사에 실패한 모든 필드의 key 값과 errormessage 를 Map에 담아 반환

```java
/* 회원가입 시, 유효성 검사 및 중복 체크 */
@Transactional(readOnly = true)
public Map<String, String> validateHandling(Errors errors) {
    Map<String, String> validatorResult = new HashMap<>();

    /* 유효성 검사, 중복 검사에 실패한 필드 목록을 받음 */
    for (FieldError error : errors.getFieldErrors()) {
        String validKeyName = String.format("valid_%s", error.getField());
        validatorResult.put(validKeyName, error.getDefaultMessage());
    }
    return validatorResult;
}
```

- 유효성 검사에 실패한 필드들은 Map 구조로 key와 Error Message 저장.
    - Key :  valid_{dto필드명}
    - Message : dto의 작성한 message값
    
- `write()` : 게시글 작성 화면에 사용자 정보 출력 역할

### **UserController**.java

validator 를 빈에 등록하고 UserService 메서드 사용

```java
public class UserController {

  /*로그인 관련*/
  private final UserService userService;

  private final CustomValidators.EmailValidator EmailValidator;
  private final CustomValidators.NicknameValidator NicknameValidator;
  private final CustomValidators.UsernameValidator UsernameValidator;

  /* 커스텀 유효성 검증을 위해 추가 */

  @InitBinder
  public void validatorBinder(WebDataBinder binder) {
      binder.addValidators(EmailValidator);
      binder.addValidators(NicknameValidator);
      binder.addValidators(UsernameValidator);
  }

  @GetMapping("/auth/join")
  public String join() {
      return "/user/user-join";
  }

  /* 회원 가입 */
  @PostMapping("/auth/joinProc")
  public String joinProc(@Valid UserDto.Request dto, Errors errors, Model model) {
      log.info("==========joinProc 진입==========");
      if (errors.hasErrors()) {
          /* 회원가입 실패 시 입력 데이터 값을 유지 */
          model.addAttribute("userDto", dto);

          log.error("Error = "+errors);

          /* 유효성 통과 못한 필드와 메세지를 핸들링 */
          Map<String, String> validatorResult = userService.validateHandling(errors);
          for (String key : validatorResult.keySet()) {
              model.addAttribute(key, validatorResult.get(key));
          }
          /* 회원가입 페이지로 다시 리턴 */
          return "/user/user-join";
      }
      userService.userJoin(dto);
      return "redirect:/auth/login";
  }
  ...
}
```

- `@InitBinder`
: 컨트롤러 클래스 내 특정 컨트롤러 메서드에 바인딩 또는 검증 설정을 변경하는 역할
(주로 HTTP 요청 파라미터를 자바 객체로 바인딩할 때 
추가적인 초기화 작업이나 데이터 변환이 필요할 때 사용)
    - `WebDataBinder binder` 
    : HTTP요청 정보를 컨트롤러 메서드의 파라미터나 모델로 바인딩 할 때 사용되는 바인딩 객체

---