# [User]기존 회원정보 수정 기능

### 구현 화면

![Untitled](%5BUser%5D%E1%84%80%E1%85%B5%E1%84%8C%E1%85%A9%E1%86%AB%20%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%20%E1%84%89%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20e1ad5ed6adb441c5b376372bc40187dc/Untitled.png)

회원의 정보(닉네임 , 비밀번호) 를 수정하는 기능

### **접근 로직**

1. 로그인을 한뒤 회원정보 수정 버튼(톱니바퀴 버튼) 을 누르면 `’/modify'` 주소 이동 
2. 주소를 매핑 하는 `UserController` 의 `modify()` 메서드를 통해 처리 후  
회원 정보 수정 페이지로 이동
3. 회원 정보 수정 페이지에서 완료 버튼을 누르면
4. app.js 의 클릭 이벤트로 유효성 체크
5. 유효성 검사의 이상이 없으면 ‘수정 하시겠습니까?’ 확인 후
ajax 의 put 형식으로 `"/api/user"` 로 이동
6. `UserApiController`의 해당 url로 매핑 된 `modify()` 메서드에서 
UserService 의 메서드 처리와 세션관련 처리후 app.js 로 리턴
7. app.js 에서 `"/"` 주소 이동

---

[BaseTimeEntity ](Date%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%A6%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20e46cebaabe6d465e9e5c6b209e5214e7.md) 

[User.java ](%E1%84%83%E1%85%A9%E1%84%86%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB(Entity)%204baede46aea54d9e8dd03bfd1914be3e.md) 

[JavaScript 와 유효성 검사 관련(app.js)](JavaScript%20%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB(app%20js)%20a7aa307c3044477393d4dd2cf4e80303.md)

---

### user/user-modify.html

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<body>
<div th:replace="~{layout/header :: header}"></div>

<div id="posts_list">
    <div class="container col-md-4">
        <form>
            <label for="id"></label>
            <input type="hidden" id="id" th:value="${user.id}"/>
            <input type="hidden" id="modifiedDate" th:value="${user.modifiedDate}"/>
            <div class="form-group">
                <label for="username">아이디</label>
                <input type="text" id="username" th:value="${user.username}" class="form-control" readonly/>
            </div>

            <div class="form-group">
                <label for="password">비밀번호</label>
                <input type="password" id="password" class="form-control" placeholder="수정할 비밀번호를 입력해주세요"/>
            </div>

            <div class="form-group">
                <label for="nickname">닉네임</label>
                <input type="text" id="nickname" th:value="${user.nickname}" class="form-control" placeholder="수정할 닉네임을 입력해주세요"/>
            </div>

            <div class="form-group">
                <label for="email">이메일</label>
                <input type="email" id="email" th:value="${user.email}" class="form-control" readonly/>
            </div>
        </form>
        <button id="btn-user-modify" class="btn btn-primary bi bi-check-lg"> 완료</button>
        <a href="/" role="button" class="btn btn-info bi bi-arrow-return-left"> 목록</a>
    </div>
</div>

<div th:replace="~{layout/footer :: footer}"></div>

</body>
</html>

```

---

### UserController.java

```java

@RequiredArgsConstructor
@Controller
@Slf4j
public class UserController {
		...
		/* 회원 정보 수정*/
    @GetMapping("/modify")
    public String modify(@LoginUser UserDto.Response user, Model model) {
        if (user != null) {
            model.addAttribute("user", user);
        }
        return "/user/user-modify";
    }
}
```

> UserService 에서 JPA의 dirty checking 을 이용하다 보니 비교적 controller 로직이 간단
> 

### UserApiController.java

```java
@RequiredArgsConstructor
@RequestMapping("/api")
@RestController
public class UserApiController {
  private final UserService userService;
  private final AuthenticationManager authenticationManager;

  @PutMapping("/user")
  public ResponseEntity<String> modify(@RequestBody UserDto.Request dto) {
      userService.modify(dto);

      /* 변경된 세션 등록 */
      Authentication authentication = authenticationManager.authenticate(
              new UsernamePasswordAuthenticationToken(dto.getUsername(), dto.getPassword()));
      SecurityContextHolder.getContext().setAuthentication(authentication);

      return new ResponseEntity<>("success", HttpStatus.OK);
  }
}
```

- `modify()`
: 변경된 세션을 바로 등록하기 위해 `UsernamePasswordAuthenticationToken`을 만들고 **AuthenticationManager**를 통해 등록. 
⇒ SecurityContextHolder 안의 Context 를 불러와 변경 된 Authentication설정
(이때 **AuthenticationManager** 를 사용하기 위해 **SecurityConfig** 에서 빈으로 등록)

### UserService.java

영속성 컨텍스트를 이용하여 data를 변경하면 자동으로 `save()`

```java
@RequiredArgsConstructor
@Service
public class UserService {
    private final UserRepository userRepository;
    private final BCryptPasswordEncoder encoder;
    
    ...

		/* 회원 수정 (dirty checking) */
    @Transactional
    public void modify(UserDto.Request dto) {
        User user = userRepository.findById(dto.toEntity().getId()).orElseThrow(() ->
                new IllegalArgumentException("해당 회원이 존재하지 않습니다."));
        String encPassword = encoder.encode(dto.getPassword());
        user.modify(dto.getNickname(), encPassword);
    }
 }
```

- `modify()` 
: Dirty Checking 을 이용하여 데이터의 값이 변경하면 트랜잭션이 끝나는 시점에 변경된 data를 반영
    
    <aside>
    💡 **Dirty Checking?**
    트랜잭션 안에서 DB의 data를 가져오면 데이터는 영속성 컨텍스트가 유지되는 상태가 되고 이 상태에서 data를 변경하면 트랜잭션이 끝나는 시점에 변경된 data를 DB에 반영
    
    </aside>
    
    <aside>
    💡 **영속성 Context?**
    **엔티티(Entity)**를 영구 저장하는 환경으로 데이터베이스와의 상호작용을 추상화하고, 엔티티의 생명주기를 관리하여 데이터베이스와의 일관성을 유지하는 것이 특징
    
    </aside>
    

---