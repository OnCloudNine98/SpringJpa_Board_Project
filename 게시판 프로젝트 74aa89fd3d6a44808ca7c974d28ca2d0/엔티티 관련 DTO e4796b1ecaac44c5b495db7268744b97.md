# 엔티티 관련 DTO

보통 엔티티가 변경되면 API 스펙이 변하는 문제를 대비하기 위해 DTO를 사용하고는 하지만 
이번 프로젝트 에서는 request, response DTO 클래스를 하나로 묶어 
InnerStaticClass로 한 번에 관리하는데 사용 된다.

> **Request** [DTO가 요청 받아 처리]
주로 클라이언트에서 서버로 데이터를 전송하는 용도로 사용돼 DTO에 요청이 들어 오면
**유효성을 검사** 등을 한 후 엔티티 객체로 변환하는 기능
**Response** [DTO가 처리후 응답/반납]
주로 서버에서 클라이언트로 데이터를 전송하는 용도로 사용 돼
엔티티 객체를 DTO로 변환한후 다시 클라이언트로 전달하는 역할
> 

[Entity 와 DTO의 역할에 따른 차이](%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B5%E1%84%90%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20DTO%20e4796b1ecaac44c5b495db7268744b97/Entity%20%E1%84%8B%E1%85%AA%20DTO%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A6%20%E1%84%84%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5%203d1681747c714d719d6b9b3336028c86.md)

### CommentDto.java

User 와 N대1 양방향 관계 , Posts 와 N대1 단방향 관계

```java
public class CommentDto {
    /**
     * 댓글 Service 요청을 위한 DTO 클래스
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class Request {
        private Long id;
        private String comment;
        private String createdDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy.MM.dd HH:mm"));
        private String modifiedDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy.MM.dd HH:mm"));
        private User user;
        private Posts posts;

        /* DTO -> Entity */
        public Comment toEntity() {
            Comment comments = Comment.builder()
                    .id(id)
                    .comment(comment)
                    .createdDate(createdDate)
                    .modifiedDate(modifiedDate)
                    .user(user)
                    .posts(posts)
                    .build();

            return comments;
        }
    }

    /**
     * 댓글 정보를 리턴할 응답(Response) 클래스
     */
    @RequiredArgsConstructor
    @Getter
    public static class Response {
        private Long id;
        private String comment;
        private String createdDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy.MM.dd HH:mm")) ;
        private String modifiedDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy.MM.dd HH:mm"));
        private String nickname;
        private Long userId;
        private Long posts;

        /* DTO -> Entity */
        public Response(Comment comment) {
            this.id = comment.getId();
            this.comment = comment.getComment();
            this.createdDate = comment.getCreatedDate();
            this.modifiedDate = comment.getModifiedDate();
            this.nickname = comment.getUser().getNickname();
            this.userId = comment.getUser().getId();
            this.posts = comment.getPosts().getId();
        }

    }

}

```

> 별도의 **Response 클래스**가 있는 이유 
Entity 클래스를 생성자 파라미터로 받아 데이터를 Dto로 변환하여 응답함으로써
별도의 전달 객체를 활용해 연관관계를 맺은 엔티티간의 무한참조를 방지
> 
- `@Builer`
:  Builder Pattern 을 쉽게 구현 할수 있도록 도와주는 Annotation 으로 다음의 특징이 있음
    1. 객체를 생성할 때 **Method Chaining 방식**으로 필드를 설정 할 수 있게 해 가독성을 놉힘
        
        ```java
        User user = User.builder()
                        .name("John Doe")
                        .age(30)
                        .email("john.doe@example.com")
                        .build();
        ```
        
    2. 필요하지 않은 필드는 설정하지 않아도 가능하게 하여 유연한 객체를 생성

---

### PostsDto.java

User 와 N대1 단방향 관계 

```java
public class PostsDto {
  /**
   * 게시글의 등록과 수정을 처리할 요청(Request) 클래스
   */
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public static class Request {
      private Long id;
      private String title;
      private String writer;
      private String content;
      private String  createDate , modifiedDate;
      private int view;
      private User user;

      /* Dto -> Entity */
      public Posts toEntity() {
          Posts posts = Posts.builder()
                  .id(id)
                  .title(title)
                  .writer(writer)
                  .content(content)
                  .view(0)
                  .user(user)
                  .build();

          return posts;
      }
  }

  /**
   * 게시글 정보를 리턴할 응답(Response) 클래스
   */
  @Getter
  public static class Response {
      private final Long id;
      private final String title;
      private final String writer;
      private final String content;
      private final String createDate , modifiedDate;
      private final int view;
      private final Long userId;
      private final List<CommentDto.Response> comments;

      /* Entity -> Dto*/
      public Response(Posts posts) {
          this.id = posts.getId();
          this.title = posts.getTitle();
          this.writer = posts.getWriter();
          this.content = posts.getContent();
          this.createDate = posts.getCreatedDate();
          this.modifiedDate = posts.getModifiedDate();
          this.view = posts.getView();
          this.userId = posts.getUser().getId();
          this.comments = posts.getComments().stream().map(CommentDto.Response::new).collect(Collectors.toList());
      }

  }
}
```

> 별도의 **Response 클래스**가 있는 이유 
Entity 클래스를 생성자 파라미터로 받아 데이터를 Dto로 변환하여 응답함으로써
별도의 전달 객체를 활용해 연관관계를 맺은 엔티티간의 무한참조를 방지
> 
- `@NoArgsConstructor`
:  파라미터가 **없는** 기본 생성자를 자동으로 생성
- `@AllArgsConstructor`
: Lombok 라이브러리에서 제공하는 Annotation으로 
클래스의 **모든 필드**를 인수로 갖는 생성자를 자동으로 생성

---

### UserDto.java

```java
public class UserDto {

    /**
     * 회원 Service 요청(Request) DTO 클래스
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class Request {
        private Long id;

        @Pattern(regexp = "^[ㄱ-ㅎ가-힣a-z0-9-_]{4,20}$",message = "아이디는 특수문자를 제외한 4~20자리 여야 합니다.")
        @NotBlank(message = "아이디는 필수 입력 값입니다.")
        private String username;

        @Pattern(regexp = "(?=.*[0-9])(?=.*[a-zA-Z])(?=.*\\W)(?=\\S+$).{8,16}" , message = "비밀번호는 8~16자의 영문 대 소문자, 숫자, 특수문자를 사용하세요.")
        private String password;

        @Pattern(regexp = "^[ㄱ-ㅎ가-힣a-zA-Z0-9-_]{2,10}$" ,message = "닉네임은 특수문자를 제외한 2~10자리 여야 합니다.")
        @NotBlank(message = "닉네임은 필수 입력 값입니다.")
        private String nickname;

        @Pattern(regexp = "^(?:\\w+\\.?)*\\w+@(?:\\w+\\.)+\\w+$" ,message = "이메일 형식이 올바르지 않습니다.")
        @NotBlank(message = "이메일은 필수 입력 값입니다.")
        private String email;

        private Role role;

        /* DTO -> Entity */
        public User toEntity() {
            User user = User.builder()
                    .id(id)
                    .username(username)
                    .password(password)
                    .nickname(nickname)
                    .email(email)
                    .role(role.USER)
                    .build();

            return user;
        }
    }

    /**
     * 인증된 사용자 정보를 세션에 저장하기 위한 클래스
     */
    @Getter
    public static class Response implements Serializable {
        private final Long id;
        private final String username;
        private final String nickname;
        private final String email;
        private final Role role;
        private final String modifiedDate;

        /* Entity -> dto */
        public Response(User user) {
            this.id = user.getId();
            this.username = user.getUsername();
            this.nickname = user.getNickname();
            this.email = user.getEmail();
            this.role = user.getRole();
            this.modifiedDate = user.getModifiedDate();
        }

    }

}
```

> UserDto 의 Response 는 세션과 연관이 있다.
세션을 저장하기 위해 User 엔티티 클래스를 직접 사용하게 되면 **직렬화**를 해야 하는데,
엔티티 클래스에 **직렬화**를 넣어주면 추후 다른 엔티티와 연관관계를 맺을시 **직렬화 대상**에 다른 엔티티까지 포함될 수 있어 성능 이슈 생겨 세션 저장용 Dto 클래스 생성한다.
> 

<aside>
💡 **직렬화?**
객체의 상태를 **bite stream** 으로 변환하여 저장하거나 네트워크를 통해 전송할 수 
있도록 하는 과정

</aside>

- `@JoinColumn`
: JPA에서 사용 되는 Annotation으로 두 Entity 간의 관계를 정의 할 때 사용 되며 
Foreign Key 로서 **참조**되는 Column 을 지정할 때 사용.
    - 주요 속성
        - Name : 현재 엔티티의 외래 키 열 이름을 지정
        - ReferencedColumnName : 참조되는 엔티티의 기본 키 열 이름을 지정
        - Nullable : 외래 키가 `NULL` 값을 가질 수 있는지 여부를 지정
        - Insertable / Updatable : 외래 키 열이 삽입 / 수정 될수 있는지 여주를 지정
        - Unique : 외래 키 열이 유니크한지 여부를 지정
        - ColumnDefinition : 데이터베이스의 열 정의를 직접 지정
- `@Enumerated`
: JAVA enum 타입을 매핑할 때 사용.
    - 주요 속성
        - `EnumType.ORDINAL` : enum 순서를 기준으로 데이터베이스에 저장
        - `EnumType.STRING` : enum 이름을 기준으로 데이터베이스에 저장

---

### @LoginUser

```java
@Target(ElementType.PARAMETER) // 파라미터로 선언된 객체만 사용
@Retention(RetentionPolicy.RUNTIME) //런타임 까지 남아있음.
public @interface LoginUser {
}
```

> 프로젝트를 살펴 보면 사용자(User) 의 로그인은 세션과 연관이 있는데 이때 
세션과 관련하여 중복코드를 줄여주기 위해 LoginUser  Annotation을 생성하여 접근
> 

---